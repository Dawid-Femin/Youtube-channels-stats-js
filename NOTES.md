1. Zaczynam od dodania plików startowych do mojego projektu oraz instalacji wymaganych zależności.

2. Następnie przeszedłem do zaimportowania danych za pomocą interfejsu fetch API oraz wyświetlenia wymaganych elementów. W tym celu tworzę funkcję addChannels(), gdzie przy pomocy template w strukturze HTML tworzę cały szkielet element. Dla zaimportowanych i wyświetlonych danych tworzę style zaczynając projektowanie od rozdzielczości na urządzenia typu mobile. Zgodnie z założeniami widoki zostały przygotowanie pod kątem responsywności, a główne rozdzielczości jakie brałem pod uwagę to 360px, 945px, 1280px oraz 1680px.

3. Kolejnym krokiem było stworzenie funkcji umożliwiającej sortowanie kanałów za pomocą inputów typu radio z lewej strony. Za pomocą querySellectorAll pobrałem wszystkie inputy z atrybutem name="sort". Na inputy ustawiam nasłuchiwanie za pomocą addEventListenera, dzięki czemu za pomocą value dodanego do kodu HTML i pomocniczej zmiennej select mogę segregować kanały według ich nazw. Podczas sortowania pojawił się problem z wartościami subskrybentów, obejrzeń i filmów. Przecinki, kropki czy białe znaki uniemożliwiały poprawe sortowanie, więc stwrzona została funkcja removeSign(), która zamieniała niepotrzebne znaki na pustego stringa. Funkcję removeString użyłem również do usunięcia zbędnych znaków podczas wypełniania zmiennych. Liczby w notacji imperialnej uzyskałem stosując metodę toLocaleString('en').

4. Stworzyłem button reverse oraz pobrałem go za pomocą querySellector. Button umieściłem w prostej funkcji, gdzie do parametru wyświetlane dane i odwracam data za pomocą data.reverse(), kontener zawierający informacje o kanałach czyszczę, a następnie wywołuje funkcję tworzącą listę kanałów w odwróconej kolejności.

5. Dalej przeszedłem do napisania funkcji odpowiedzialniej za filtrowanie danych po wpisaniu tekstu w polu input. W tym przypadku skorzystałem z wartości jaka została wpisana, następnie za pomocą forEach() przeiterowałem po channelInfo w celu sprawdzenia czy nazwa zawiera wartość wpisaną w input. Na tej podstawie elementom, które nie zawierały nazwy kanału dodawałem klasę hide, a te które zawierały nazwę pozostawały widoczne.